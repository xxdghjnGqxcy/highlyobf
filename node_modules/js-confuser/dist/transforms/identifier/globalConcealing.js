"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _template = _interopRequireDefault(require("../../templates/template"));
var _transform = _interopRequireDefault(require("../transform"));
var _order = require("../../order");
var _gen = require("../../util/gen");
var _insert = require("../../util/insert");
var _random = require("../../util/random");
var _constants = require("../../constants");
var _probability = require("../../probability");
var _globalAnalysis = _interopRequireDefault(require("./globalAnalysis"));
var _bufferToString = require("../../templates/bufferToString");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Global Concealing hides global variables being accessed.
 *
 * - Any variable that is not defined is considered "global"
 */
class GlobalConcealing extends _transform.default {
  constructor(o) {
    super(o, _order.ObfuscateOrder.GlobalConcealing);
    _defineProperty(this, "globalAnalysis", void 0);
    _defineProperty(this, "ignoreGlobals", new Set(["require", "__dirname", "eval", _constants.variableFunctionName]));
    this.globalAnalysis = new _globalAnalysis.default(o);
    this.before.push(this.globalAnalysis);
  }
  match(object, parents) {
    return object.type == "Program";
  }
  transform(object, parents) {
    return () => {
      var globals = this.globalAnalysis.globals;
      this.globalAnalysis.notGlobals.forEach(del => {
        delete globals[del];
      });
      for (var varName of this.ignoreGlobals) {
        delete globals[varName];
      }
      _constants.reservedIdentifiers.forEach(x => {
        delete globals[x];
      });
      Object.keys(globals).forEach(x => {
        if (this.globalAnalysis.globals[x].length < 1) {
          delete globals[x];
        } else if (!(0, _probability.ComputeProbabilityMap)(this.options.globalConcealing, x => x, x)) {
          delete globals[x];
        }
      });
      if (Object.keys(globals).length > 0) {
        var usedStates = new Set();

        // Make getter function

        // holds "window" or "global"
        var globalVar = this.getPlaceholder();
        var getGlobalVariableFnName = this.getPlaceholder() + _constants.predictableFunctionTag;

        // Returns global variable or fall backs to `this`
        var getGlobalVariableFn = (0, _bufferToString.createGetGlobalTemplate)(this, object, parents).compile({
          getGlobalFnName: getGlobalVariableFnName
        });

        // 2. Replace old accessors
        var globalFn = this.getPlaceholder() + _constants.predictableFunctionTag;
        var newNames = Object.create(null);
        Object.keys(globals).forEach(name => {
          var locations = globals[name];
          var state;
          do {
            state = (0, _random.getRandomInteger)(-1000, 1000 + usedStates.size);
          } while (usedStates.has(state));
          usedStates.add(state);
          newNames[name] = state;
          locations.forEach(_ref => {
            var _this$options$lock;
            let [node, p] = _ref;
            if (p.find(x => x.$multiTransformSkip)) {
              return;
            }
            var newExpression = (0, _gen.CallExpression)((0, _gen.Identifier)(globalFn), [(0, _gen.Literal)(state)]);
            this.replace(node, newExpression);
            if ((_this$options$lock = this.options.lock) !== null && _this$options$lock !== void 0 && _this$options$lock.tamperProtection && this.lockTransform.nativeFunctionName) {
              var isMemberExpression = false;
              var nameAndPropertyPath = [name];
              var callExpression;
              var index = 0;
              do {
                if (p[index].type === "CallExpression") {
                  callExpression = p[index];
                  break;
                }
                var memberExpression = p[index];
                if (memberExpression.type !== "MemberExpression") return;
                var property = memberExpression.property;
                var stringValue = property.type === "Literal" ? property.value : memberExpression.computed ? null : property.type === "Identifier" ? property.name : null;
                if (!stringValue) return;
                isMemberExpression = true;
                nameAndPropertyPath.push(stringValue);
                index++;
              } while (index < p.length);
              if (!this.lockTransform.shouldTransformNativeFunction(nameAndPropertyPath)) return;
              if (callExpression && callExpression.type === "CallExpression") {
                if (isMemberExpression) {
                  callExpression.callee = (0, _gen.CallExpression)((0, _gen.Identifier)(this.lockTransform.nativeFunctionName), [callExpression.callee.object, callExpression.callee.computed ? callExpression.callee.property : (0, _gen.Literal)(callExpression.callee.property.name || callExpression.callee.property.value)]);
                } else {
                  callExpression.callee = (0, _gen.CallExpression)((0, _gen.Identifier)(this.lockTransform.nativeFunctionName), [{
                    ...callExpression.callee
                  }]);
                }
              }
            }
          });
        });

        // Adds all global variables to the switch statement
        this.options.globalVariables.forEach(name => {
          if (!newNames[name]) {
            var state;
            do {
              state = (0, _random.getRandomInteger)(0, 1000 + usedStates.size + this.options.globalVariables.size * 100);
            } while (usedStates.has(state));
            usedStates.add(state);
            newNames[name] = state;
          }
        });
        var indexParamName = this.getPlaceholder();
        var returnName = this.getPlaceholder();
        var functionDeclaration = (0, _gen.FunctionDeclaration)(globalFn, [(0, _gen.Identifier)(indexParamName)], [(0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)(returnName)), (0, _gen.SwitchStatement)((0, _gen.Identifier)(indexParamName), Object.keys(newNames).map(name => {
          var code = newNames[name];
          var body = [(0, _gen.ReturnStatement)((0, _gen.MemberExpression)((0, _gen.Identifier)(globalVar), (0, _gen.Literal)(name), true))];
          if ((0, _random.chance)(50)) {
            body = [(0, _gen.ExpressionStatement)((0, _gen.AssignmentExpression)("=", (0, _gen.Identifier)(returnName), (0, _gen.LogicalExpression)("||", (0, _gen.Literal)(name), (0, _gen.MemberExpression)((0, _gen.Identifier)(globalVar), (0, _gen.Literal)(name), true)))), (0, _gen.BreakStatement)()];
          }
          return (0, _gen.SwitchCase)((0, _gen.Literal)(code), body);
        })), (0, _gen.ReturnStatement)((0, _gen.MemberExpression)((0, _gen.Identifier)(globalVar), (0, _gen.Identifier)(returnName), true))]);
        var tempVar = this.getPlaceholder();
        var variableDeclaration = new _template.default(`
        var ${globalVar};
        `).single();
        variableDeclaration.declarations.push((0, _gen.VariableDeclarator)(tempVar, (0, _gen.CallExpression)((0, _gen.MemberExpression)((0, _gen.FunctionExpression)([], [...getGlobalVariableFn, new _template.default(`return ${globalVar} = ${getGlobalVariableFnName}["call"](this)`).single()]), (0, _gen.Literal)("call"), true), [])));
        (0, _insert.prepend)(object, variableDeclaration);
        (0, _insert.append)(object, functionDeclaration);
      }
    };
  }
}
exports.default = GlobalConcealing;