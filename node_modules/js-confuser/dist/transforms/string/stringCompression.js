"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _assert = require("assert");
var _order = require("../../order");
var _probability = require("../../probability");
var _template = _interopRequireDefault(require("../../templates/template"));
var _compare = require("../../util/compare");
var _gen = require("../../util/gen");
var _insert = require("../../util/insert");
var _transform = _interopRequireDefault(require("../transform"));
var _constants = require("../../constants");
var _random = require("../../util/random");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function LZ_encode(c) {
  (0, _assert.ok)(c);
  var x = "charCodeAt",
    b,
    e = {},
    f = c.split(""),
    d = [],
    a = f[0],
    g = 256;
  for (b = 1; b < f.length; b++) c = f[b], null != e[a + c] ? a += c : (d.push(1 < a.length ? e[a] : a[x](0)), e[a + c] = g, g++, a = c);
  d.push(1 < a.length ? e[a] : a[x](0));
  for (b = 0; b < d.length; b++) d[b] = String.fromCharCode(d[b]);
  return d.join("");
}
function LZ_decode(b) {
  (0, _assert.ok)(b);
  var o,
    f,
    a,
    e = {},
    d = b.split(""),
    c = f = d[0],
    g = [c],
    h = o = 256;
  for (var i = 1; i < d.length; i++) a = d[i].charCodeAt(0), a = h > a ? d[i] : e[a] ? e[a] : f + c, g.push(a), c = a.charAt(0), e[o] = f + c, o++, f = a;
  return g.join("");
}
const DecodeTemplate = new _template.default(`function {name}(b){
    var o,
    f,
    a,
    e = {},
    d = b.split(""),
    c = (f = d[0]),
    g = [c],
    h = (o = 256);
  for (b = 1; b < d.length; b++)
    (a = d[b].charCodeAt(0)),
      (a = h > a ? d[b] : e[a] ? e[a] : f + c),
      g.push(a),
      (c = a.charAt(0)),
      (e[o] = f + c),
      o++,
      (f = a);
  return g.join("").split("{delimiter}");
  }`);
class StringCompression extends _transform.default {
  constructor(o) {
    super(o, _order.ObfuscateOrder.StringCompression);
    _defineProperty(this, "map", void 0);
    _defineProperty(this, "ignore", void 0);
    _defineProperty(this, "string", void 0);
    _defineProperty(this, "delimiter", "|");
    _defineProperty(this, "fnName", void 0);
    this.map = new Map();
    this.ignore = new Set();
    this.string = "";
    this.fnName = this.getPlaceholder() + _constants.predictableFunctionTag;
  }
  apply(tree) {
    super.apply(tree);
    this.string = this.string.slice(0, this.string.length - 1);
    if (!this.string.length) {
      return;
    }
    var split = this.getPlaceholder();
    var decoder = this.getPlaceholder();
    var getStringName = this.getPlaceholder() + _constants.predictableFunctionTag; // Returns the string payload

    var encoded = LZ_encode(this.string);
    if (LZ_decode(encoded) !== this.string) {
      this.error(new Error("String failed to be decoded. Try disabling the 'stringCompression' option."));
    }
    var getStringParamName = this.getPlaceholder();
    var decoderParamName = this.getPlaceholder();
    var callExpression = (0, _gen.CallExpression)((0, _gen.Identifier)(decoderParamName), [(0, _gen.CallExpression)((0, _gen.Identifier)(getStringParamName), [])]);
    (0, _insert.prepend)(tree, (0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)(split, (0, _gen.CallExpression)((0, _gen.FunctionExpression)([(0, _gen.Identifier)(getStringParamName), (0, _gen.Identifier)(decoderParamName)], [(0, _gen.ReturnStatement)(callExpression)]), [(0, _gen.Identifier)(getStringName), (0, _gen.Identifier)(decoder)]))));
    var keys = new Set();
    var keysToMake = (0, _random.getRandomInteger)(4, 14);
    for (var i = 0; i < keysToMake; i++) {
      keys.add((0, _random.getRandomString)((0, _random.getRandomInteger)(4, 14)));
    }
    var objectExpression = (0, _gen.ObjectExpression)(Array.from(keys).map(key => {
      return (0, _gen.Property)((0, _gen.Literal)(key), (0, _random.getRandomFalseExpression)(), true);
    }));

    // Get string function
    var getStringBody = [];
    var splits = (0, _random.splitIntoChunks)(encoded, Math.floor(encoded.length / (0, _random.getRandomInteger)(3, 6)));
    getStringBody.push((0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)("str", (0, _gen.Literal)(splits.shift()))));
    getStringBody.push((0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)("objectToTest", objectExpression)));
    const addIfStatement = (testingFor, literalValueToBeAppended) => {
      getStringBody.push((0, _gen.IfStatement)((0, _gen.BinaryExpression)("in", (0, _gen.Literal)(testingFor), (0, _gen.Identifier)("objectToTest")), [(0, _gen.ExpressionStatement)((0, _gen.AssignmentExpression)("+=", (0, _gen.Identifier)("str"), (0, _gen.Literal)(literalValueToBeAppended)))]));
    };
    for (const split of splits) {
      if ((0, _random.chance)(50)) {
        var fakeKey;
        do {
          fakeKey = (0, _random.getRandomString)((0, _random.getRandomInteger)(4, 14));
        } while (keys.has(fakeKey) || fakeKey in {});
        addIfStatement(fakeKey, (0, _random.getRandomString)(split.length));
      }
      addIfStatement((0, _random.choice)(Array.from(keys)), split);
    }

    // Return computed string
    getStringBody.push((0, _gen.ReturnStatement)((0, _gen.Identifier)("str")));
    (0, _insert.append)(tree, (0, _gen.FunctionDeclaration)(getStringName, [], getStringBody));
    (0, _insert.append)(tree, (0, _gen.FunctionDeclaration)(this.fnName, [(0, _gen.Identifier)("index")], [(0, _gen.ReturnStatement)((0, _gen.MemberExpression)((0, _gen.Identifier)(split), (0, _gen.Identifier)("index"), true))]));
    (0, _insert.append)(tree, DecodeTemplate.single({
      name: decoder,
      delimiter: this.delimiter
    }));
  }
  match(object, parents) {
    return object.type == "Literal" && typeof object.value === "string" && object.value && object.value.length > 3 && !(0, _compare.isDirective)(object, parents) && !(0, _compare.isModuleSource)(object, parents) && !parents.find(x => x.$multiTransformSkip);
  }
  transform(object, parents) {
    if (!object.value) {
      return;
    }
    if (this.ignore.has(object.value) || object.value.includes(this.delimiter)) {
      return;
    }
    if (!parents[0] || parents[0].type == "CallExpression" && parents[0].callee.type == "Identifier" && parents[0].callee.name == this.fnName) {
      return;
    }
    if (!(0, _probability.ComputeProbabilityMap)(this.options.stringCompression, x => x, object.value)) {
      return;
    }
    var index = this.map.get(object.value);

    // New string, add it!
    if (typeof index !== "number") {
      // Ensure the string gets properly decoded
      if (LZ_decode(LZ_encode(object.value)) !== object.value) {
        this.ignore.add(object.value);
        return;
      }
      index = this.map.size;
      this.map.set(object.value, index);
      this.string += object.value + this.delimiter;
    }
    (0, _assert.ok)(typeof index === "number");
    return () => {
      this.replaceIdentifierOrLiteral(object, (0, _gen.CallExpression)((0, _gen.Identifier)(this.fnName), [(0, _gen.Literal)(index)]), parents);
    };
  }
}
exports.default = StringCompression;