"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _parser = require("../parser");
var _assert = require("assert");
var _random = require("../util/random");
var _traverse = _interopRequireDefault(require("../traverse"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Templates provides an easy way to parse code snippets into AST subtrees.
 *
 * These AST subtrees can added to the obfuscated code, tailored with variable names.
 *
 * 1. Basic string interpolation
 *
 * ```js
 * var Base64Template = new Template(`
 * function {name}(str){
 *   return btoa(str)
 * }
 * `);
 *
 * var functionDeclaration = Base64Template.single({ name: "atob" });
 * ```
 *
 * 2. AST subtree insertion
 *
 * ```js
 * var Base64Template = new Template(`
 * function {name}(str){
 *   {getWindow}
 *
 *   return {getWindowName}btoa(str)
 * }`)
 *
 * var functionDeclaration = Base64Template.single({
 *  name: "atob",
 *  getWindowName: "newWindow",
 *  getWindow: () => {
 *    return acorn.parse("var newWindow = {}").body[0];
 *  }
 * });
 * ```
 *
 * Here, the `getWindow` variable is a function that returns an AST subtree. This must be a `Node[]` array or Template.
 * Optionally, the function can be replaced with just the `Node[]` array or Template if it's already computed.
 *
 * 3. Template subtree insertion
 *
 * ```js
 * var NewWindowTemplate = new Template(`
 *   var newWindow = {};
 * `);
 *
 * var Base64Template = new Template(`
 * function {name}(str){
 *   {NewWindowTemplate}
 *
 *   return newWindow.btoa(str)
 * }`)
 *
 * var functionDeclaration = Base64Template.single({
 *  name: "atob",
 *  NewWindowTemplate: NewWindowTemplate
 * });
 * ```
 */
class Template {
  constructor() {
    _defineProperty(this, "templates", void 0);
    _defineProperty(this, "defaultVariables", void 0);
    _defineProperty(this, "requiredVariables", void 0);
    for (var _len = arguments.length, templates = new Array(_len), _key = 0; _key < _len; _key++) {
      templates[_key] = arguments[_key];
    }
    this.templates = templates;
    this.defaultVariables = Object.create(null);
    this.requiredVariables = new Set();
    this.findRequiredVariables();
  }
  setDefaultVariables(defaultVariables) {
    this.defaultVariables = defaultVariables;
    return this;
  }
  findRequiredVariables() {
    var matches = this.templates[0].match(/{[$A-z0-9_]+}/g);
    if (matches !== null) {
      matches.forEach(variable => {
        var name = variable.slice(1, -1);

        // $ variables are for default variables
        if (name.startsWith("$")) {
          throw new Error("Default variables are no longer supported.");
        } else {
          this.requiredVariables.add(name);
        }
      });
    }
  }

  /**
   * Interpolates the template with the given variables.
   *
   * Prepares the template string for AST parsing.
   *
   * @param variables
   */
  interpolateTemplate() {
    let variables = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var allVariables = {
      ...this.defaultVariables,
      ...variables
    };

    // Validate all variables were passed in
    for (var requiredVariable of this.requiredVariables) {
      if (typeof allVariables[requiredVariable] === "undefined") {
        throw new Error(this.templates[0] + " missing variable: " + requiredVariable + " from " + JSON.stringify(allVariables));
      }
    }
    var template = (0, _random.choice)(this.templates);
    var output = template;
    Object.keys(allVariables).forEach(name => {
      var bracketName = "{" + name.replace("$", "\\$") + "}";
      var value = allVariables[name] + "";
      if (typeof allVariables[name] !== "string") {
        value = name;
      }
      var reg = new RegExp(bracketName, "g");
      output = output.replace(reg, value);
    });
    return {
      output,
      template
    };
  }

  /**
   * Finds the variables in the AST and replaces them with the given values.
   *
   * Note: Mutates the AST.
   * @param ast
   * @param variables
   */
  interpolateAST(ast, variables) {
    var allVariables = {
      ...this.defaultVariables,
      ...variables
    };
    var astNames = new Set(Object.keys(allVariables).filter(name => {
      return typeof allVariables[name] !== "string";
    }));
    if (astNames.size === 0) return;
    (0, _traverse.default)(ast, (o, p) => {
      if (o.type === "Identifier" && allVariables[o.name]) {
        return () => {
          var value = allVariables[o.name];
          (0, _assert.ok)(typeof value !== "string");
          var insertNodes = typeof value === "function" ? value() : value;
          if (insertNodes instanceof Template) {
            insertNodes = insertNodes.compile(allVariables);
          }
          if (!Array.isArray(insertNodes)) {
            // Replace with expression

            Object.assign(o, insertNodes);
          } else {
            // Insert multiple statements/declarations
            var expressionStatement = p[0];
            var body = p[1];
            (0, _assert.ok)(expressionStatement.type === "ExpressionStatement");
            (0, _assert.ok)(Array.isArray(body));
            var index = body.indexOf(expressionStatement);
            body.splice(index, 1, ...insertNodes);
          }
        };
      }
    });
  }
  compile() {
    let variables = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var {
      output,
      template
    } = this.interpolateTemplate(variables);
    var program;
    try {
      program = (0, _parser.parseSnippet)(output);
    } catch (e) {
      throw new Error(output + "\n" + "Template failed to parse: " + e.message);
    }
    this.interpolateAST(program, variables);
    return program.body;
  }
  single() {
    let variables = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var nodes = this.compile(variables);
    if (nodes.length !== 1) {
      nodes = nodes.filter(node => node.type !== "EmptyStatement");
      (0, _assert.ok)(nodes.length === 1, `Expected single node, got ${nodes.map(node => node.type).join(", ")}`);
    }
    return nodes[0];
  }
}
exports.default = Template;